/*
 * (C) Copyright IBM Corp. 2018, 2021
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package com.ibm.fhir.persistence.jdbc.util;

import static com.ibm.fhir.persistence.jdbc.JDBCConstants.AND;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.COMBINED_RESULTS;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.FETCH_FIRST;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.JOIN;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.LEFT_PAREN;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.LIMIT;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.RIGHT_PAREN;
import static com.ibm.fhir.persistence.jdbc.JDBCConstants.ROWS_ONLY;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import com.ibm.fhir.persistence.exception.FHIRPersistenceException;
import com.ibm.fhir.persistence.jdbc.connection.QueryHints;
import com.ibm.fhir.persistence.jdbc.dao.api.JDBCIdentityCache;
import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;
import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;
import com.ibm.fhir.search.SearchConstants;
import com.ibm.fhir.search.parameters.InclusionParameter;

/**
 * This class assists the JDBCQueryBuilder. It extends the
 * QuerySegmentAggregator to build a FHIR Resource query
 * that processes _include and _revinclude search result parameters. Using the
 * query segments built by the query builder,
 * this class augments those query segments to result in a query that includes
 * other resources as determined by
 * InclusionParameter objects.
 */
public class InclusionQuerySegmentAggregator extends QuerySegmentAggregator {
    private static final String CLASSNAME = InclusionQuerySegmentAggregator.class.getName();
    private static final Logger log = java.util.logging.Logger.getLogger(CLASSNAME);

    private static final String SELECT_COUNT_ROOT = "SELECT COUNT(DISTINCT RESOURCE_ID) FROM ";
    private static final String SELECT_ROOT =
            "SELECT RESOURCE_ID, LOGICAL_RESOURCE_ID, VERSION_ID, LAST_UPDATED, IS_DELETED, DATA, LOGICAL_ID FROM ";
    private static final String SELECT_ROOT_WITH_SORT_ORDER =
            "SELECT RESOURCE_ID, LOGICAL_RESOURCE_ID, VERSION_ID, LAST_UPDATED, IS_DELETED, DATA, LOGICAL_ID, 1 AS SORT_ORDER FROM ";
    private static final String UNION_ALL = " UNION ALL ";
    private static final String ORDERING = " ORDER BY R.LOGICAL_RESOURCE_ID ASC ";
    private static final String SORT_ORDER_COLUMN = ", 2 AS SORT_ORDER ";
    private static final String ORDER_BY_SORT_ORDER = " ORDER BY SORT_ORDER ASC ";

    private List<InclusionParameter> includeParameters;
    private List<InclusionParameter> revIncludeParameters;
    private final JDBCIdentityCache identityCache;

    protected InclusionQuerySegmentAggregator(Class<?> resourceType, int offset, int pageSize,
            ParameterDAO parameterDao, ResourceDAO resourceDao,
            List<InclusionParameter> includeParameters, List<InclusionParameter> revIncludeParameters, QueryHints queryHints,
            JDBCIdentityCache identityCache) {
        super(resourceType, offset, pageSize, parameterDao, resourceDao, queryHints);
        this.includeParameters    = includeParameters;
        this.revIncludeParameters = revIncludeParameters;
        this.identityCache = identityCache;
    }

    /**
     * This methods builds a query to return the count of resources matching the
     * search. This count will encompass resources
     * represented by _include and _revinclude parameters.
     * <p>
     * The following generated SQL is an example. It is based on this REST query
     * string:
     * {@code /Patient?id=some-id&_include=Patient:organization&_revinclude=Observation:patient}
     * <p>
     * See comments embedded in the SQL for explanation:
     *
     * <pre>
       SELECT COUNT(RESOURCE_ID) FROM
       -- The following SELECT is the query for the "target" Patient resource. It is generated by superclass methods.
           (SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID FROM
          Patient_RESOURCES R JOIN
          Patient_LOGICAL_RESOURCES LR ON R.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID JOIN
          Patient_TOKEN_VALUES P1 ON P1.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID WHERE
          R.IS_DELETED = 'N' AND
          P1.RESOURCE_ID = R.RESOURCE_ID AND
          (P1.PARAMETER_NAME_ID=1 AND ((P1.TOKEN_VALUE = ?)))

       UNION ALL

       -- The following part of the overall query is built by the processInlcudeParameters() method.
       -- The following SELECT is generated in order to retrieve the desired included Organization resources that are
       -- referenced by the target Patient resources.
       SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID FROM
         Organization_RESOURCES R JOIN
         Organization_LOGICAL_RESOURCES LR ON R.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID WHERE
         R.IS_DELETED = 'N' AND
         R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID AND
         (LR.LOGICAL_ID IN
           (SELECT P1.TOKEN_VALUE FROM
            Patient_TOKEN_VALUES_V P1 WHERE
            P1.PARAMETER_NAME_ID=19 AND P1.CODE_SYSTEM_ID = {n}
            P1.RESOURCE_ID IN
            (SELECT R.RESOURCE_ID FROM
             Patient_RESOURCES R JOIN
             Patient_LOGICAL_RESOURCES LR ON R.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID JOIN
             Patient_TOKEN_VALUES P1 ON P1.LOGICAL_RESOURCE_ID=R.LOGICAL_RESOURCE_ID WHERE
             R.IS_DELETED = 'N' AND
             P1.RESOURCE_ID = R.RESOURCE_ID AND
             (P1.PARAMETER_NAME_ID=1 AND ((P1.TOKEN_VALUE = ?)))
            )
           )
         )

         UNION ALL

         -- The following part of the overall query is built by the processRevInlcudeParameters() method.
         -- The following SELECT is generated in order to retrieve the desired reverse included Observation resources
         -- that reference the target Patient resources.
         SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID FROM
          Observation_RESOURCES R JOIN
          Observation_LOGICAL_RESOURCES LR ON R.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID JOIN
          Observation_STR_VALUES P1 ON P1.RESOURCE_ID = R.RESOURCE_ID WHERE
          R.IS_DELETED = 'N' AND
          P1.PARAMETER_NAME_ID=29 AND
          P1.STR_VALUE IN
           (SELECT 'Patient/' || LR.LOGICAL_ID FROM
            Patient_RESOURCES R JOIN
            Patient_LOGICAL_RESOURCES LR ON R.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID JOIN
            Patient_TOKEN_VALUES P1 ON P1.RESOURCE_ID=R.RESOURCE_ID WHERE
            R.IS_DELETED = 'N' AND
            P1.RESOURCE_ID = R.RESOURCE_ID AND
            (P1.PARAMETER_NAME_ID=1 AND ((P1.TOKEN_VALUE = ?)))
           )
         )
       COMBINED_RESULTS
     * </pre>
     */
    @Override
    protected SqlQueryData buildCountQuery() throws Exception {
        final String METHODNAME = "buildCountQuery";
        log.entering(CLASSNAME, METHODNAME);

        StringBuilder queryString = new StringBuilder();
        queryString.append(SELECT_COUNT_ROOT);
        queryString.append(LEFT_PAREN);
        queryString.append(QuerySegmentAggregator.SELECT_ROOT);
        buildFromClause(queryString, resourceType.getSimpleName());

        // An important step here is to add _id and _lastUpdated and then
        // the regular bind variables.
        List<Object> allBindVariables = new ArrayList<>();
        allBindVariables.addAll(idsObjects);
        allBindVariables.addAll(lastUpdatedObjects);
        this.addBindVariables(allBindVariables);

        // Add the Where Clause
        buildWhereClause(queryString, null);
        queryString.append(COMBINED_RESULTS);
        addOptimizerHint(queryString);

        SqlQueryData queryData = new SqlQueryData(queryString.toString(), allBindVariables);
        log.exiting(CLASSNAME, METHODNAME);
        return queryData;
    }

    /**
     * This methods builds a query to return the resources which are the target of
     * the search, along with other resources
     * specified by _include and rev_include parameters. The SQL generated by this
     * method is the same as that generated
     * by the buildCountQuery() method with the following exceptions:
     * 1. The "root" SELECT selects individual columns instead of a COUNT.
     * 2. Pagination clauses are added to the end of the query.
     *
     * @see The javadoc for the buildCountQuery() method for an example of the
     *      generated SQL along with a detailed
     *      explanation.
     */
    @Override
    protected SqlQueryData buildQuery() throws Exception {
        final String METHODNAME = "buildQuery";
        log.entering(CLASSNAME, METHODNAME);

        StringBuilder queryString = new StringBuilder();
        queryString.append(InclusionQuerySegmentAggregator.SELECT_ROOT).append(LEFT_PAREN);
        queryString.append(InclusionQuerySegmentAggregator.SELECT_ROOT_WITH_SORT_ORDER).append(LEFT_PAREN);
        queryString.append(QuerySegmentAggregator.SELECT_ROOT);

        buildFromClause(queryString, resourceType.getSimpleName());

        // An important step here is to add _id and _lastUpdated
        // then add the regular bind variables.
        List<Object> allBindVariables = new ArrayList<>();
        allBindVariables.addAll(super.idsObjects);
        allBindVariables.addAll(super.lastUpdatedObjects);
        this.addBindVariables(allBindVariables);

        buildWhereClause(queryString, null);

        // Add ordering
        queryString.append(ORDERING);
        this.addPaginationClauses(queryString);
        queryString.append(") RESULT ");
        this.processIncludeParameters(queryString, allBindVariables);
        this.processRevIncludeParameters(queryString, allBindVariables);

        queryString.append(COMBINED_RESULTS).append(ORDER_BY_SORT_ORDER);
        this.addLimitClause(queryString);

        addOptimizerHint(queryString);

        SqlQueryData queryData = new SqlQueryData(queryString.toString(), allBindVariables);
        log.exiting(CLASSNAME, METHODNAME);
        return queryData;
    }

    /**
     * Build subquery that will be joined to main query to get a list of references of included resources
     *
     * <pre>
     * JOIN (
     *   SELECT DISTINCT
     *     P1.TOKEN_VALUE AS LOGICAL_ID,
     *     P1.REF_VERSION_ID AS VERSION_ID,
     *     R.VERSION_ID AS CUR_VERSION_ID,
     *     R.LOGICAL_RESOURCE_ID AS LOGICAL_RESOURCE_ID
     *   FROM
     *     <resourceType>_TOKEN_VALUES_V P1
     *     JOIN <searchParameterTargetType>_LOGICAL_RESOURCES LR ON P1.TOKEN_VALUE = LR.LOGICAL_ID
     *     JOIN <searchParameterTargetType>_RESOURCES R ON LR.CURRENT_RESOURCE_ID = R.RESOURCE_ID AND R.IS_DELETED = 'N'
     *   WHERE
     *     P1.PARAMETER_NAME_ID = <id>
     *     AND P1.CODE_SYSTEM_ID = <codeSystemId>
     *     AND P1.LOGICAL_RESOURCE_ID IN (
     *       SELECT
     *         R.LOGICAL_RESOURCE_ID
     *       FROM
     *         <resourceType>_LOGICAL_RESOURCES LR
     *         JOIN <resourceType>_RESOURCES R ON R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID AND R.IS_DELETED = 'N'
     *         JOIN <resourceType>_TOKEN_VALUES_V AS param0 ON (
     *           param0.PARAMETER_NAME_ID = <id>
     *           AND (
     *             (param0.TOKEN_VALUE = ?)
     *           )
     *         )
     *         AND LR.LOGICAL_RESOURCE_ID = param0.LOGICAL_RESOURCE_ID
     *       ORDER BY
     *         R.LOGICAL_RESOURCE_ID ASC OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
     *     )
     * ) REFS ON REFS.LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID
     *           AND COALESCE(REFS.VERSION_ID, REFS.CUR_VERSION_ID) = R.VERSION_ID
     * </pre>
     *
     * @param queryString
     *              The non-null StringBuilder
     * @param includeParm
     *              The include search parameter
     * @param bindVariables
     *              The associated bind variables
     * @throws Exception
     */
    private void processIncludeSubQuery(StringBuilder queryString, InclusionParameter includeParm, List<Object> bindVariables) throws Exception {

        // The code system for the target resource type of the search parameter. This is required
        // because we need to filter values from the token values which may match a logical id from
        // more than one resource type. This would previously be done by prepending the resource type
        // to the logical id being referenced, but that is no longer the case since issue #1366.
        int resourceTypeCodeSystemId = getCodeSystemId(includeParm.getSearchParameterTargetType());

        // JOIN (
        //   SELECT DISTINCT
        //     P1.TOKEN_VALUE AS LOGICAL_ID,
        //     P1.REF_VERSION_ID AS VERSION_ID,
        //     R.VERSION_ID AS CUR_VERSION_ID,
        //     R.LOGICAL_RESOURCE_ID AS LOGICAL_RESOURCE_ID
        //   FROM <resourceType>_TOKEN_VALUES_V P1
        queryString.append(JOIN).append(LEFT_PAREN)
                .append("SELECT DISTINCT P1.TOKEN_VALUE AS LOGICAL_ID, P1.REF_VERSION_ID AS VERSION_ID, R.VERSION_ID AS CUR_VERSION_ID, R.LOGICAL_RESOURCE_ID AS LOGICAL_RESOURCE_ID FROM ")
                .append(this.resourceType.getSimpleName()).append("_TOKEN_VALUES_V P1");

        // JOIN <includeParmTargetType>_LOGICAL_RESOURCES LR ON P1.TOKEN_VALUE = LR.LOGICAL_ID
        queryString.append(JOIN).append(includeParm.getSearchParameterTargetType())
                .append("_LOGICAL_RESOURCES LR ON P1.TOKEN_VALUE = LR.LOGICAL_ID");

        // JOIN <includeParmTargetType>_RESOURCES R ON LR.CURRENT_RESOURCE_ID = R.RESOURCE_ID
        queryString.append(JOIN).append(includeParm.getSearchParameterTargetType())
                .append("_RESOURCES R ON LR.CURRENT_RESOURCE_ID = R.RESOURCE_ID AND R.IS_DELETED = 'N'");

        // WHERE P1.PARAMETER_NAME_ID=xx AND P1.CODE_SYSTEM_ID = {n} AND
        queryString.append(" WHERE P1.PARAMETER_NAME_ID=")
                .append(this.getParameterNameId(includeParm.getSearchParameter())).append(AND)
                .append("P1.CODE_SYSTEM_ID=").append(resourceTypeCodeSystemId).append(AND);

        // P1.LOGICAL_RESOURCE_ID IN (SELECT R.LOGICAL_RESOURCE_ID
        queryString.append("P1.LOGICAL_RESOURCE_ID IN (SELECT R.LOGICAL_RESOURCE_ID ");

        // Add FROM clause for "root" resource type
        buildFromClause(queryString, resourceType.getSimpleName());

        // An important step here is to add _id and _lastUpdated
        bindVariables.addAll(this.idsObjects);
        bindVariables.addAll(this.lastUpdatedObjects);
        this.addBindVariables(bindVariables);

        // Add WHERE clause for "root" resource type
        buildWhereClause(queryString, null);

        // ORDER BY R.LOGICAL_RESOURCE_ID ASC
        queryString.append(ORDERING);

        // Only include resources related to the required page of the main resources.
        this.addPaginationClauses(queryString);

        // Close IN clause
        queryString.append(RIGHT_PAREN);

        // ) REFS ON REFS.LOGICAL_RSOURCE_ID = R.LOGICAL_RESOURCE_ID AND COALESCE(REFS.VERSION_ID, REFS.CUR_VERSION_ID) = R.VERSION_ID
        queryString.append(") REFS ON REFS.LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID AND COALESCE(REFS.VERSION_ID, REFS.CUR_VERSION_ID) = R.VERSION_ID ");
    }

    /**
     * Build subquery that will be joined to main query to get a list of references of revincluded resources
     *
     * <pre>
     * JOIN (
     *   SELECT
     *     LR.LOGICAL_ID AS LOGICAL_ID,
     *     R.VERSION_ID AS CUR_VERSION_ID,
     *   FROM
     *     <resourceType>_LOGICAL_RESOURCES LR
     *     JOIN <resourceType>_RESOURCES R ON R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID AND R.IS_DELETED = 'N'
     *   ORDER BY
     *     R.LOGICAL_RESOURCE_ID ASC OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
     * ) REFS ON P1.TOKEN_VALUE = REFS.LOGICAL_ID
     *           AND COALESCE(P1.REF_VERSION_ID, REFS.CUR_VERSION_ID) = REFS.CUR_VERSION_ID
     * </pre>
     *
     * @param queryString
     *              The non-null StringBuilder
     * @param includeParm
     *              The include search parameter
     * @param bindVariables
     *              The associated bind variables
     * @throws Exception
     */
    private void processRevIncludeSubQuery(StringBuilder queryString, InclusionParameter includeParm, List<Object> bindVariables) throws Exception {

        // JOIN (
        //   SELECT
        //     LR.LOGICAL_ID AS LOGICAL_ID,
        //     R.VERSION_ID AS CUR_VERSION_ID,
        queryString.append(JOIN).append(LEFT_PAREN)
                .append("SELECT LR.LOGICAL_ID AS LOGICAL_ID, R.VERSION_ID AS CUR_VERSION_ID ");

        // Add FROM clause for "root" resource type
        buildFromClause(queryString, resourceType.getSimpleName());

        // An important step here is to add _id and _lastUpdated
        bindVariables.addAll(this.idsObjects);
        bindVariables.addAll(this.lastUpdatedObjects);
        this.addBindVariables(bindVariables);

        // Add WHERE clause for "root" resource type
        buildWhereClause(queryString, null);

        // ORDER BY R.LOGICAL_RESOURCE_ID ASC
        queryString.append(ORDERING);

        // Only include resources related to the required page of the main resources.
        this.addPaginationClauses(queryString);

        // ) REFS ON REFS.LOGICAL_ID = P1.TOKEN_VALUE AND COALESCE(P1.REF_VERSION_ID, REFS.CUR_VERSION_ID) = R.VERSION_ID
        queryString.append(") REFS ON P1.TOKEN_VALUE = REFS.LOGICAL_ID AND COALESCE(P1.REF_VERSION_ID, REFS.CUR_VERSION_ID) = REFS.CUR_VERSION_ID ");
    }

    /**
     * Formats the FROM clause instead of assembling a String MessageFormat
     * The code here is just building as part of the StringBuilder.
     *
     * @param queryString
     *              The non-null StringBuilder
     * @param target
     *              The Target Type for the search
     * @param isRevInclude
     *              A boolean indicating if this is a revInclude search
     */
    private void processFromClause(StringBuilder queryString, String target, boolean isRevInclude) {
        queryString.append("FROM ");
        queryString.append(target);
        queryString.append("_RESOURCES R JOIN ");
        queryString.append(target);
        queryString.append("_LOGICAL_RESOURCES LR ON ");
        if (isRevInclude) {
            queryString.append("R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID JOIN ")
                        .append(target)
                        .append("_TOKEN_VALUES_V P1 ON R.LOGICAL_RESOURCE_ID = P1.LOGICAL_RESOURCE_ID");
        } else {
            queryString.append("R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID ");
        }
    }

    /**
     * Build query for each include parameter.
     *
     * @param queryString
     *              The non-null StringBuilder
     * @param bindVariables
     *              The associated bind variables
     * @throws Exception
     */
    private void processIncludeParameters(StringBuilder queryString, List<Object> bindVariables) throws Exception {
        final String METHODNAME = "processIncludeParameters";
        log.entering(CLASSNAME, METHODNAME);

        for (InclusionParameter includeParm : this.includeParameters) {
            // UNION ALL
            queryString.append(UNION_ALL);
            // SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID, 2 AS SORT_ORDER
            queryString.append(QuerySegmentAggregator.SELECT_ROOT).append(SORT_ORDER_COLUMN);
            // FROM <resourceType>_RESOURCES R JOIN <resourceType>_LOGICAL_RESOURCES LR ON R.LOGICAL_RESOURCE_ID=LR.LOGICAL_RESOURCE_ID
            processFromClause(queryString, includeParm.getSearchParameterTargetType(), false);
            // JOIN (...) REFS ON REFS.LOGICAL_ID = LR.LOGICAL_ID AND COALESCE(REFS.VERSION_ID, REFS.CUR_VERSION_ID) = R.VERSION_ID
            processIncludeSubQuery(queryString, includeParm, bindVariables);
        }
        log.exiting(CLASSNAME, METHODNAME);
    }

    /**
     * Build query for each revinclude parameter.
     *
     * @param queryString
     *              The non-null StringBuilder
     * @param bindVariables
     *              The associated bind variables
     * @throws Exception
     */
    private void processRevIncludeParameters(StringBuilder queryString, List<Object> bindVariables) throws Exception {
        final String METHODNAME = "processRevIncludeParameters";
        log.entering(CLASSNAME, METHODNAME);

        for (InclusionParameter includeParm : this.revIncludeParameters) {
            // UNION ALL
            queryString.append(UNION_ALL);
            // SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID, 2 AS SORT_ORDER
            queryString.append(QuerySegmentAggregator.SELECT_ROOT).append(SORT_ORDER_COLUMN);
            // FROM Observation_RESOURCES R
            // JOIN Observation_LOGICAL_RESOURCES LR ON R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID
            // JOIN Observation_TOKEN_VALUES_V P1 ON R.LOGICAL_RESOURCE_ID = P1.LOGICAL_RESOURCE_ID
            processFromClause(queryString, includeParm.getJoinResourceType(), true);
            // JOIN (...) REFS ON REFS.LOGICAL_ID = P1.TOKEN_VALUE AND COALESCE(P1.REF_VERSION_ID, REFS.CUR_VERSION_ID) = R.VERSION_ID
            processRevIncludeSubQuery(queryString, includeParm, bindVariables);
            // WHERE R.IS_DELETED = 'N' AND P1.PARAMETER_NAME_ID = xx AND P1.CODE_SYSTEM_ID = xx
            queryString.append(QuerySegmentAggregator.WHERE_CLAUSE_ROOT)
                        .append(" AND P1.PARAMETER_NAME_ID = ").append(this.getParameterNameId(includeParm.getSearchParameter()))
                        .append(" AND P1.CODE_SYSTEM_ID = ").append(getCodeSystemId(includeParm.getSearchParameterTargetType()));
        }
        log.exiting(CLASSNAME, METHODNAME);
    }

    /**
     * Returns the integer id that corresponds to the passed search parameter name.
     *
     * @param searchParameterName
     * @return Integer
     * @throws FHIRPersistenceException
     */
    private int getParameterNameId(String searchParameterName) throws FHIRPersistenceException {
        final String METHODNAME = "getParameterNameId";
        log.entering(CLASSNAME, METHODNAME);

        Integer parameterNameId = identityCache.getParameterNameId(searchParameterName);
        if (parameterNameId == null) {
            parameterNameId = -1; // need a value to keep query syntax valid
        }

        log.exiting(CLASSNAME, METHODNAME);
        return parameterNameId;
    }

    private int getCodeSystemId(String codeSystemName) throws FHIRPersistenceException {
        Integer result = identityCache.getCodeSystemId(codeSystemName);
        if (result == null) {
            result = -1;
        }
        return result;
    }

    /**
     * Adds the bind variables contained in all of the query segments contained in
     * this instance to the passed collection.
     *
     * @param bindVariables
     */
    private void addBindVariables(List<Object> bindVariables) {
        final String METHODNAME = "addBindVariables";
        log.entering(CLASSNAME, METHODNAME);

        for (SqlQueryData querySegment : this.querySegments) {
            bindVariables.addAll(querySegment.getBindVariables());
        }

        log.exiting(CLASSNAME, METHODNAME);
    }

    /**
     * Adds the appropriate limit clause to the passed query string buffer,
     * based on the type of database we're running against.
     *
     * @param queryString
     *              The non-null StringBuilder
     */
    private void addLimitClause(StringBuilder queryString) {
        int limit = Integer.MAX_VALUE;
        if (this.pageSize <= Integer.MAX_VALUE - (SearchConstants.MAX_PAGE_SIZE + 1)) {
            limit = this.pageSize + SearchConstants.MAX_PAGE_SIZE + 1;
        }

        if (this.parameterDao.isDb2Database()) {
            queryString.append(LIMIT).append(limit);
        } else {
            queryString.append(FETCH_FIRST).append(limit).append(ROWS_ONLY);
        }
    }
}